# Stack & Queue

담당자: 황승현
상태: 자료구조

## 스택(Stack)

---

![Untitled](Stack%20&%20Qu%201e12c/Untitled.png)

스택(Stack)은 데이터를 차곡차곡 쌓아 올린 형태의 자료구조이다. 위의 사진과 같이 데이터가 순서대로 쌓이며, 가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 구조를 가지고 있다.

스택은 정해진 방향으로만 쌓을 수 있으며, **top**으로 정한 곳을 통해서만 접근할 수 있다. 새로 삽입되는 자료는 top이 가리키는 가장 맨 위에 쌓이게 되며, 자료를 삭제할 때도 top을 통해서 삭제가 가능하다.

스택에서는 삽입 연산을 **push**, 삭제 연산을 **pop**이라고 하며, 이러한 스택의 구조를 **후입 선출(LIFO: Last In First Out)**이라고 한다.

스택에서 push와 pop을 할 때는 해당 위치를 알고 있어야 하므로 기억하고 있는 ‘스택 포인터(SP)’가 필요하다.

### 시간 복잡도

`top` 위치의 데이터에 바로 접근이 가능하기 때문에 데이터 삽입, 삭제의 시간 복잡도는 O(1)이다.

### 대표적인 스택의 활용

- 컴퓨터 내부의 프로세스 구조의 함수 동작 방식
- 재귀 알고리즘
- DFS 알고리즘
- 작업 실행 취소와 같은 역추적 작업이 필요할 때
- 괄호 검사, 후위 연산법, 문자열 역순 출력 등

### 장단점

### 장점

- `top` 을 통해 접근하기 때문에 데이터 접근, 삽입, 삭제가 빠르다
- 구조가 단순해서 구현이 쉽다
- 데이터 저장/읽기 속도가 빠르다

### 단점

- `top` 위치 이외의 데이터에 접근할 수 없기 때문에 탐색이 불가능하다. 탐색하려면 모든 데이터를 꺼내면서 진행해야 한다.
- 데이터 최대 갯수를 미리 정해야 한다(파이썬 재귀 함수는 1000번까지만 호출이 가능함)
- 저장 공간의 낭비가 발생할 수 있다(미리 최대 갯수만큼 저장 공간을 확보해야 함.

스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는 것이 일반적이다. 이 경우, 위에서 열거한 단점이 있을 수 있다.

## 큐(Queue)

---

![Untitled](Stack%20&%20Qu%201e12c/Untitled%201.png)

큐(Queue)는 스택과 다르게 먼저 들어온 것이 먼저 나가는 “선입선출(FIFO: First In First Out)”의 구조를 가지고 있다.

삭제 연산이 수행되는 곳을 프론트(Front), 삽입 연산이 이루어지는 곳은 리어(Rear)로, FIFO 구조를 위해서 스택과 다르게 큐의 한쪽 끝에는 삽입 작업이, 다른 한쪽 끝에서는 삭제 작업이 나뉘어서 이루어지고 있다.

큐는 리어에서 이루어지는 삽인 연산을 **인큐(Enqueue)**라고 부르며, 프론트에서 이루어지는 삭제 연산을 **디큐(Dequeue)**라고 부른다.

### 시간복잡도

큐 역시 front, rear의 위치로 데이터 삽입 삭제가 바로 이루어지기 때문에 원소 삽입, 삭제의 시간 복잡도는 O(1)이다.

### 대표적인 큐의 활용

- 멀티태스킹을 위한 프로세스 스케줄링 방식의 구현
- 데이터를 입력된 순서대로 처리해야 할 때
- BFS 알고리즘
- 프로세스 관리
- 대기 순서 관리

### 장단점

- 데이터 접근, 삽입, 삭제가 빠르다.
- 큐 역시 스택과 마찬가지로 중간에 위치한 데이터에 대한 접근이 불가능하다.

스택과 큐에서의 삽입과 삭제 연산을 표로 비교하면 다음과 같다.

![Untitled](Stack%20&%20Qu%201e12c/Untitled%202.png)

## 데크(Deque)

---

![Untitled](Stack%20&%20Qu%201e12c/Untitled%203.png)

데크(Deque)는 Double-Ended Queue의 줄임말이다.

한쪽에서만 삽입, 다른 한쪽에서만 삭제가 가능했던 큐와 달리, 양쪽 front, rear에서 삽입 삭제가 모두 가능한 큐를 의미하는 자료구조이다.

연속적인 메모리를 기반으로 하는 시퀀스 컨테이너 이고 선언 이후 크기를 줄이거나 늘릴 수 있는 가변적 크기를 갖는다.

또한 중간에 데이터가 삽입될 때 다른 요소들을 앞, 뒤로 밀 수 있다. `vector` 보다는 좋은 성능을 가지지만 앞, 뒤에서의 삽입 삭제 성능에 비해 중간에 삽입 삭제 하는 것은 성능이 좋지 않다!

### 시간 복잡도

삽입 삭제 연산은 마찬가지로 **O(1)** 의 시간 복잡도를 가지고, 스택/큐와 달리 index 를 통해 요소들에 탐색이 가능하므로 이 역시 **O(1)** 의 시간 복잡도를 가진다.

### 장단점

- 데이터의 삽입 삭제가 빠르고 앞, 뒤에서 삽입 삭제가 모두 가능하다
- 가변적 크기
- index 를 통해 임의의 원소에 바로 접근이 가능하고
- 새로운 원소 삽입 시, 메모리를 재할당하고 복사하지 않고 새로운 단위의 메모리 블록을 할당하여 삽입한다.
- 중간에서의 삽입 삭제가 어렵고
- 스택, 큐에 비해 비교적 구현이 어렵다.

스택과 큐에서의 삽입과 삭제 연산을 표로 비교하면 다음과 같다.

![Untitled](Stack%20&%20Qu%201e12c/Untitled%202.png)

## 참고

---

- 파이썬은 스택 자료형을 별도로 제공하지 않지만, 리스트가 사실상 스택의 모든 연산을 지원한다. 큐 또한 마찬가지다. 다만, 리스트는 동적 배열로 구현되어 있어 큐의 연산을 수행하기에는 효율적이지 않기 때문에, 큐를 위해서는 **데크(deque)**라는 별도의 자료형을 사용해야 좋은 성능을 낼 수 있다.
- 스택은 콜 스택이라 하여, 컴퓨터 프로그램의 서브루틴에 대한 정보를 저장하는 자료구저에도 널리 활용된다. 컴파일러가 출력하는 에러도 스택처럼 맨 마지막 에러가 가장 먼저 출력되는 순서를 보인다. 또한, 스택은 메모리 영역에서 LIFO 형태로 할당하고 접근하는 구조인 아키텍처 레벨의 하드웨어 스택의 이름으로도 널리 사용된다.

### 출처

---

[https://jud00.tistory.com/entry/자료구조-스택Stack과-큐Queue에-대해서-알아보자](https://jud00.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9DStack%EA%B3%BC-%ED%81%90Queue%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

[https://brightwon.tistory.com/8](https://brightwon.tistory.com/8)

[https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Stack %26 Queue.md](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Stack%20%26%20Queue.md)

[https://velog.io/@yusokk/algorithm-dstructure1](https://velog.io/@yusokk/algorithm-dstructure1)

[https://velog.io/@nnnyeong/자료구조-스택-Stack-큐-Queue-덱-Deque](https://velog.io/@nnnyeong/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9D-Stack-%ED%81%90-Queue-%EB%8D%B1-Deque)

[https://velog.io/@yusokk/algorithm-dstructure1](https://velog.io/@yusokk/algorithm-dstructure1)